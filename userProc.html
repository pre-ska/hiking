<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Document</title>
    <style>
      body {
        margin: 50px;
        padding-top: 50px;
        font-size: 20px;
      }

      h1 {
        text-align: center;
      }
      li {
        margin-left: 20px;
      }
    </style>
  </head>
  <body>
    <h3>userModel.js</h3>
    <li>kreiram <b>userSchema</b> i <b>User model</b></li>
    <hr />

    <h3>authController.js</h3>
    <li>kreiram metode <b> User modela</b></li>
    <li>
      <b>exports.signup</b>...async funkcija koja po modelu kreira novog usera u
      DB, podaci stizu u <i>req.body</i>
    </li>
    <li>vratim u RESPONSE taj objekt sa statusom 201 (successfully created)</li>
    <li>
      cijelu exports metodu wrapam u <b>catchAsync()</b>, tako da ne moram
      stalno try/catch pisati, vec imam sve u toj funkciji - u njoj hvatam sve
      moguÄ‡e errore
    </li>
    <hr />

    <h3>userRoutes.js</h3>
    <li>kreiram rute</li>
    <hr />

    <h3>userModel.js</h3>
    <li>validate confirmPassword</li>
    <li>dodaj pre-hook za enkripciju passworda (prije "save")</li>
    <li>jwt</li>
    <li>login metoda</li>
    <li>
      userModel - schema - password - select: false ... da mi ne vraca password
      polje na klijentsku stranu
    </li>
    <li>osim ako ga explicitno ne zatrazim .select("+password")</li>
    <li>
      ako email i password polje u REQESTU postoji, zatrazim iz DB taj dokument
      usera po emailu (+password)
    </li>
    <li>
      ako taj dokument postoji, ispitam dali je hash passworda iz DB jednak
      passwordu iz REQUESTA (bcrypt.compare)
    </li>
    <li>ako nesto od ovoga ne prodje, bacim error u next()</li>
    <li>
      ako sve prodje, izradim token sa signToken funkcijom i vratim taj token na
      frontend
    </li>
    <hr />

    <h1>PROTECTED ROUTES</h1>
    <i>
      zelim npr da mi <b>getAllTours</b> bude zasticena ruta, tj. da samo
      registrirani korisnici mogu to vidit
    </i>

    <h3>authController.js</h3>
    <li>
      kreiram middleware funkciju <b>.protect()</b> za bilo koju zasticenu rutu
      koja treba ispitati dali je korisnik logiran
    </li>
    <hr />

    <h3>tourRoutes.js 10-8</h3>
    <li>
      <b>authController.protect</b> stavim prije
      <b>tourController.getAllTours</b>
    </li>
    <hr />

    <h3>authController.js</h3>
    <li>
      ako user nije authenticated, <b>next()</b> ce baciti error, ako je ->
      proci ce dalje u pipeline
    </li>
    <li>
      prvo ispitam dali headers <b>req.headers</b> sadrzi
      <i>Authorization</i> token
    </li>
    <li>
      ako sadrzi, koristim <b>promisify</b> metodu iz Node-a nad drugom metodom
      iz JWT library-a...jer mi treba <i>promise</i>
    </li>
    <li>
      ta druga metoda je <b>jwt.verify()</b>, njoj dam token i secret koja je
      <i>enviroment varijabla</i>... JWT usporedi dali se tokeni podudaraju
    </li>
    <li>
      ukoliko nesto ne valja, <b>AppError</b> ce presresti error i izbaciti
      gresku, ili INVALID TOKEN ili TOKEN EXPIRED
    </li>
    <li>
      napravi error handler za JWT invalid token i za token expired - u
      <b>errorControler.js</b>
    </li>
    <li>provjeri dali korsinik za kojeg je izdan token jos postoji</li>
    <li>
      provjeri dali je korsinik promjenio password u medjuvremenu - otkad je JWT
      izdan - ZA OVU PROVJERU RADIM NOVU METODU NA DOKUMENTU...DOKUMENT JE
      INSTANCA MODELA, A KAD DODAM METODU NA MODEL, SVE INSTANCE (DOKUMENTI) JE
      SADRZE ------ ZATO OVU METODU RADIM KAO STATICKU U MODELU!!! ...a ne u
      errorControleru
    </li>
    <li>
      nadalje, zbog ove metode, potrebno je da znam kada je korisnik promjenio
      password, pa cu u <b>userSchema</b> napraviti polje koje ce svaku promjenu
      passworda zavesti kao timestamp.... kasnije samo usporedim kada je token
      izdan i dali je nakon toga promjenjen password
    </li>
    <li>
      ako sve prodje u redu, pustam dalje sa <b>next()</b>...mogu dodati i
      podatke o useru na reqest object, ako zatreba kasnije...to sam i onako
      dohvacao iz DB radi kontroliranja
    </li>

    <h1>AUTHORIZATION 10-11</h1>
    <i>samo neki useri imaju vece ovlasti, a ne svi logirani useri</i><br />
    <i>npr. ne mogu svi kreirati, uredjicvati i brisati ture</i><br />
    <i
      >to radim sa middlewareom sa kojim restriktiram odredjene rute (delete)
      samo na one korisnike koji su povlasteni</i
    ><br />

    <h3>------za delete funkciju--------</h3>
    <h3>tourRoutes.js</h3>
    <li>
      DELETE ruta ---- dodam <b>authController.protect</b> prije
      <b>tourController.deleteTour</b> jer uvijek prvo moram provjeriti dali je
      korsinik logiran
    </li>
    <li>
      to je prvi middleware u delete ruti... nako njega ide
      <b>authController.restrictTo</b>
    </li>
    <li>
      USER ROLES -<b>authController.restrictTo</b> prima vrstu korsinika
      <i>admin</i>, <i>lead-guide</i>... kao argument...samo navedene role
      korsinika mogu OBRISTATI turu..tj proci restrictTo middleware
    </li>
    <h3>userModel.js</h3>
    <li>
      implementiraj <b>role</b> u user model - <i>userSchema</i> ... 'user',
      'guide', 'lead-guide', 'admin'
    </li>
    <li>
      defaultna je <b>user</b> ...nemoram za svakog pisati kada ga registriram
    </li>
    <h3>authController.js</h3>
    <li>napravi metodu <b>restrictTo</b></li>
    <li>
      posto metoda <b>restrictTo</b> prima argument a to nije moguce sa
      middlewareom, moram taj middleware wrapati u novu funkciju koja ce primiti
      argumente i vratiti taj middleware
    </li>
    <li>
      prvi middleware <b>.protect</b> je dopunio reqest object sa USER objektom
      i u njemu imam sadrzano koja je role za tog korisnika..pa ga mogu ispitati
    </li>

    <h1>PASSWORD RESET 10-12</h1>
    <i>postupak 2 koraka:</i><br />
    <b>1. forgotPassword</b><br />
    <i>korsinik posalje POST request sa email adresom na password reset rutu </i
    ><br />
    <i
      >tada ce se kreirati random token (ne JSW token) i biti ce poslan na tu
      email adresu</i
    ><br />
    <b>2. resetPassword</b><br />
    <i
      >nakon toga korsinik posalje natrag taj token zajedno sa novim passwordom
      da bi napravio update</i
    >

    <h3>authController.js</h3>
    <li>kreiram forgotPassword i resetPassword metode</li>

    <h3>userRoutes.js</h3>
    <li>
      kreiram RUTE <b>forgotPassword</b> i <b>resetPassword</b> koje te metode
      hvataju i dodam im njihove metode
    </li>

    <h3>authController.js</h3>
    <li>
      u <b>forgetPassword</b> prvo dohvatim usera po emailu koji je dostavio za
      reset
    </li>
    <li>ako taj user ne postoji, odbacim sa next-new AppError</li>
    <li>
      za izradu token cu korsititi instance metodu na modelu, jer je tako
      bolje... malo je veci kod i vezan je za svakog korisnika
    </li>

    <h3>userModel.js</h3>
    <li>napravim <b>createPasswordResetToken</b> staticku instance metodu</li>
    <li>
      za kreiranje i kriptiranje tokena koristim <b>crypto</b> -
      <i>Node build-in module</i>
    </li>
    <li>
      NIKAD NE SPREMAM U DB CISTI TOKEN...vec ga encriptiram dodatno sa crypto
      metodom
    </li>
    <li>napravim <b>random token</b> sa crypto</li>
    <li>zatim taj token kriptiram takodjer sa crypto</li>
    <li>
      da bi ga imao u DB u user objektu, moram u userModelu- schema- napraviti
      field za token <b>passwordResetToken</b>... jer moram usporediti taj token
      sa onim koji korisnik dostavi sa novim passwordom
    </li>
    <li>
      osim toga moram imati i <b>passwordResetExpires</b>... jer taj token ne
      moze trajati vjecno...zbog sigurnosti...npr 10 minuta
    </li>
    <li>
      NAPOMENA: korisniku na email ne saljem kriptiran token vec cisti
      token...bilo bi glupo poslati kriptiran token isti kao sto je spremljen u
      DB
    </li>
    <h3>SLANJE EMAILA za password reset 10-13</h3>
    <h3>email.js - u utils folderu</h3>
    <li>instaliram prvo modul <b>nodemailer</b></li>
    <li>
      <b>nodemailer</b> radi na principu da koristi neki od mail servisa npr:
      Gmail
    </li>
    <li>
      zato mu moram dati sve potrebne auth podatke da se moze logirati na moj
      Gmail account
    </li>
    <li>
      u
      <i>transporteru</i> definiram service i auth objekt (username i password
      za gmail)
    </li>
    <li>
      vrijednosti za username i password ne dajem direktno, vec is definiram kao
      env. varijable i onda ih tako korisitim
    </li>
  </body>
</html>
